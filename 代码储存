#删除数据框的一列方法
code:
df.drop('column name', axis = 1)

#给数据框的某些列重命名
code:
df.rename(columns = {'col1':'new_col1','col2':'new_col2',...,'coln':'new_coln'})

#日期处理的一个方法
code:
df.date = pd.to_datetime(df.date)
df.date.apply(lambda x: x.year*100 + x.month)

##将长面板数据化成短面板数据
(1)情景：将包含日期、股票代码、收益率的长面板数据转化成短面板数据
code:
df.pivot(idnex = "ym", columns = "code", values = "ret")
df.to_csv("table.csv")
df1 = pd.read_csv("table.csv")

##多条件筛选行的方式
(1)情景：筛选所有A股的股票——通过市场类型（筛选出市场类型为1、4、16、32的股票）
code:
df[(df['Mkttype'] == 1)|(df['mkttype'] == 4)|(df['mkttype'] == 16)|(df['mkttype'] == 32)]

#将某一列设置成索引
code1（已有列）:
df.set_index(['column'], inplace = True)
code2（新创建一个列）：
df.index = list1

#将一个表格的全部数据从字符串格式转化成int格式
code:
df.columns = map(int, df.columns)

#求两个列表的差集、并集、交集
code:
(1)差集: set(list2).difference(set(list1))  其实可以不用set,但是考虑可视性。
(2)并集: set(list2).union(set(list1))
(3)交集: set(list2).intersection(set(list1))

#根据列名来筛选多列
情景：prof中将me包含的所有股票代码的列筛选出来
code:
prof[me.columns]
情景2：筛选一些名字特定的列
code:
prof[['name1','name2','name3',...,'namen']]

#生成一个只有空值的数据框，列名和索引与现有的相同
code:
df2 = pd.DataFrame(index = df1.index, columns = df1.columns)

#将两个数据框合并
code:
df3 = pd.concat([df1, df2])  ----注意要加中括号

#生成一个现有数据框的副本，目的是要独立于原有数据框
code:
df2 = df1.copy()    -----注意不能用df2 = df1, 因为这样两者公用一个空间

#时间上的运算
情景1：将整数化为时间（比如199901化为1999-01-xx）
code:
dt = 199901
dt1 = pd.to_datetime(str(dt), format = '%Y%m')
情景2：计算与XXXX-XX-XX时间点相差Y的另一个时间点
code:
import datetime
dt2 = dt1 + datetime.timedelta(Y) 

#将Dataframe中的负数替换为特定值（比如空值）
code:
df[df<0] = np.nan

#列的重命名
情景1：读取时重命名
code:
new_col = ['new1', 'new2',... , 'newn']
pd.read_csv('data', names = new_col, header=0)
情景2：全部重命名
code:
new_col = ['new1', 'new2',... , 'newn']
dataframe.columns = new_col
情景3：部分重命名
code:
dataframe.rename(columns = {'old1':'new1','old2':'new2',...,'oldn':'newn'})

#数据框相乘
code:
df1*df2*df3*...*dfn
attention:
（1）数据框的行数必须相同
（2）所有数据框不能有非公共列
